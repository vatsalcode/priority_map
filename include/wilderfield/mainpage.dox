/*! \mainpage Priority Map Documentation
 *
 * \section intro_sec Introduction
 *
 * This is the documentation for the `wilderfield::priority_map` class.
 * The `priority_map` class is designed to manage a set of elements, each with a priority,
 * allowing for efficient retrieval, updating, and tracking of elements based on their priority.
 *
 * The source code for this project is available on GitHub:
 * <a href="https://github.com/wilderfield/priority_map">wilderfield/priority_map</a>
 *
 * \section install_sec Usage
 *
 * Here is a basic example of how to use the `priority_map` class:
 *
 * \code{.cpp}
 * #include "wilderfield/priority_map.hpp"
 *
 * // Define a priority_map instance
 * wilderfield::priority_map<int, int> pmap;
 *
 * // Increment priority of key 7
 * ++pmap[7];
 *
 * // Retrieve and check the top element
 * auto [key, value] = pmap.top();
 * std::cout << "Top element key: " << key << " with priority: " << value << std::endl;
 *
 * \endcode
 *
 * \section test_sec Example Test Case
 *
 * Below is an example test case from the main suite, illustrating topological sort using Khan's algorithm:
 *
 * \code{.cpp}
 *
 *       std::vector<int> topological;
 *
 *       // Construct priority map with lower values as highest priority
 *       wilderfield::priority_map<int, int, std::less<int>> pmap;
 *
 *       // Test graph
 *       std::vector<std::vector<int>> graph(6);
 *       // Insert edges
 *
 *       // Initialize pmap to have all nodes with indegree 0
 *       for (int u = 0; u < graph.size(); u++) {
 *           pmap[u] = 0;
 *       }
 *
 *       // Calculate indegrees for each node
 *       for (int u = 0; u < graph.size(); u++) {
 *           for (auto v : graph[u]) {
 *               ++pmap[v];
 *           }
 *       }
 *
 *       // Iterate over nodes by smallest indegree
 *       while (!pmap.empty()) {
 *           auto [u, minVal] = pmap.top(); pmap.pop();
 *           REQUIRE(minVal == 0); // If not the graph has a cycle
 *           topological.push_back(u);
 *           for (auto v : graph[u]) { // Decrease indegrees after removing node u
 *               --pmap[v];
 *           }
 *       }
 *
 *       return topological;
 * \endcode
 *
 * For more information and advanced usage, refer to the respective class and method documentation.
 */

